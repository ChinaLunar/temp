Consider the limitations and disadvantages of autowiring:

  * 使用`property`和`construct-arg`进行依赖定义优先覆盖装配装配。开发者不能自动装配基本类型、字符串和`Classes`等简单类型的字面量（以及这些简单类型的数组）。这是由设计决定的
  * 自动装配的结果不如明确定义依赖注入清晰明确。虽然，如上表所记录的那样，Spring 尽可能避免粗略的猜测要装配的内容从而导致的不可预期的结果，但是和直接定义依赖相比，自动装配下 Spring 所管理的对象之间的关系却不能够清晰的记录下来
  * Spring 容器可能无法提供相应的装配信息给那些用于生成文档的工具
  * 在容器中可能会有多个 bean 定义匹配需要装配的 setter 方法或构造器的参数类型。这对于数组，集合或 Map 而言，不再是不能解决的问题；然而，对于那些希望之装配单个依赖的属性（参数）而言，却无法完成匹配，如果没有唯一的定义与之匹配的话，将会抛出相应的异常

在之后的应用中，开发者有如下选择：

  * 放弃使用自动装配功能
  * 通过使用在下一节介绍的方法，将 bean 定义的`autowire-candidate`属性设置为`false`从而将当前 bean 排除在自动装配候选项之外
  * 通过在`<bean/>`元素上设置`primary`属性为`true`，将某个 bean 定义指定为 *首选的* 候选装配项
  * 通过基于注解的配置方式，实现更有条理的控制，详见[《7.9 基于注解的容器配置》][annotation]


## 屏蔽 bean 的自动装配 ##

开发者可以通过对单个 bean 的配置将其排除在自动装配候选项之外。在 Spring 的 XML 配置中，将`<bean/>`元素的`autowire-candidate`属性设置为`false`，容器不会再将指定的 bean 作为候选项提供给自动装配（包括使用注解`@Autowired`配置的自动装配)

>[icon][icon]
`autowire-candidate`属性设计得只能够影响基于类型的自动装配。

















[annotation]: http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-annotation-config "《7.9 基于注解的容器配置》"
