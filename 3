# 7.5.4.request，session，globalSession，application 和 WebSocket 作用域 #

`request`、`session`、`globalSession`、`application`和`websocket`作用域仅在开发者使用 web 敏感的`ApplicationContext`实现（例如`XmlWebApplicationContext`）的时候才会提供。如果开发者在常规的 Spring IoC 容器（例如`ClassPathXmlApplicationContext`）中使用这些作用的话，会导致抛出`IllegalStateException`异常


## 初始化 web 配置 ##

为了支持为 bean 配置`request`、`session`、`globalSession`、`application`或`websocket`作用域，开发者需要在定义 bean 之前进行一些中级配置。（标准作用域`singleton`或`prototype`不需要这些初始化步骤）

如何完成初始化配置取决于开发者所采用的特定 Servlet 环境

如果开发者使用 Spring Web MVC 框架，特别是在 Spring `DispatcherServlet`或`DispatcherPortlet`处理的请求中，访问这些作用域的 bean，那就不需要其他特殊的步骤了：`DispatcherServlet`和`DispatcherPortlet`已经完成了所需的操作

如果开发者使用 Servlet 2.5 web 容器，然后在 Spring `DispatcherServlet`之外（例如，使用 JSF 或者 Struts）处理请求的话，开发者需要注册`org.springframework.web.context.request.RequestContextListener ServletRequestListener`。对于 Servlet 3.0 而言，可以模式化的通过`WebApplicationInitializer`接口完成。作为可替代方案，或者对于那些老的容器而言，可以在`web.xml`文件中声明 web 应用配置：

```xml
<web-app>
    ...
    <listener>
        <listener-class>
            org.springframework.web.context.request.RequestContextListener
        </listener-class>
    </listener>
    ...
</web-app>
```

如果不便于配置监听器的话，可以考虑选择使用 Spring 的`RequestContextFilter`方案。该过滤器的映射依赖于外围 web 应用的配置，所以开发者需要参考如下配置内容进行修改：

```xml
<web-app>
    ...
    <filter>
        <filter-name>requestContextFilter</filter-name>
        <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>requestContextFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

`DispatcherServlet`、`RequestContextListener`和`RequestContextFilter`所做的操作都是相同的，即将 HTTP 请求对象绑定到为该请求服务的`Thread`上。这使得 request 和 session 作用域的 bean 可以随调用链（call chain）推进下去


## requets 作用域 ##

请参考以下 bean 的 XML 配置：

```xml
<bean id="loginAction" class="com.foo.LoginAction" scope="request"/>
```

Spring 会根据`loginAction` bean 的定义为每个 HTTP 请求创建一个新的`LoginAction` bean 的实例。也就是说`loginAction` bean 被限制在 HTTP request（请求）级别。开发者可以在对象内部任意的修改对象的状态，因为根据`loginAction` bean 定义创建出来的其他实例不受这些改动的影响；对于独立的请求而言每个实例都是独立的。当完成请求之后，`request`作用域下当前请求的所有 bean 都会被丢弃

当使用注解驱动组件或 Java 配置的时候，可以使用`@RequestScope`注解定义组件为`request`作用域

```java
@RequestScope
@Component
public class LoginAction {
    // ...
}
```


## session 作用域 ##

请参考以下 bean 的 XML 配置：

```xml
<bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/>
```

在 HTTP 会话存活期间，Spring 容器会根据`userPreferences` bean 的定义为每个 HTTP 会话创建一个新的`UserPreferences` bean 的实例。换而言之，`userPreferences` bean 被有效的限制在 HTTP Session（会话）级别。如同 request 作用域的 bean 一样，开发者可以在对象内部任意的修改对象的状态，因为根据`userPreferences` bean 定义创建出来的其他实例不受这些改动的影响；对于独立的 HTTP 会话而言每个实例都是独立的。当 HTTP 会话最终被丢弃的时候，`session`作用域下的当前会话的所有 bean 都会被丢弃

当使用注解驱动组件或 Java 配置的时候，可以使用`@SessionScope`注解定义组件为`session`作用域

```xml
@SessionScope
@Component
public class UserPreferences {
    // ...
}
```


## globalSession 作用域 ##

请参考以下 bean 的 XML 配置：

```xml
<bean id="userPreferences" class="com.foo.UserPreferences" scope="globalSession"/>
```

`globalSession`作用域和上一节所描述的标准的 HTTP Session 作用域类似，并且只能在基于 portlet 的 web 应用中使用。portlet 规范之中定义了全局会话的概念：组成单个 portlet web 应用的所有 portlet 共享的 session。定义在`globalSession`作用域中的所有 bean 都被限制在（或绑定到）全局 portlet `Session`的生命周期中（上）

如果开发者在标准的基于 Servlet 的 web 应用中定义一个或多个`globalSession`作用域的 bean 的话，那么实际使用的是 HTTP Session 作用域，且不会抛出任何错误


## application 作用域 ##

请参考以下 bean 的 XML 配置：

```xml
<bean id="appPreferences" class="com.foo.AppPreferences" scope="application"/>
```

Spring 容器根据`appPreferences` bean 定义为整个 web 应用创建一次且只创建一个`AppPreferences` bean 的实例。也就是说，`appPreferences` bean 被限定`ServletContext`级别，储存为`ServletContext`的普通属性。这与 Spring singleton 作用域的 bean 在某些地方相似，但有两个主要的不同：
  1. `application`作用域下的 bean 是每个`ServletContext`范围内一个单例，而不是每个 Spring `ApplicationContext`（一个 web 应用中可能含有多个`ApplicationContext`）内一个单例
  2. `application`作用域下的 bean 是`ServletContext`的属性，对其一定可见

当使用注解驱动组件或 Java 配置的时候，可以使用`@ApplicationScope`注解定义组件为`application`作用域

```java
@ApplicationScope
@Component
public class AppPreferences {
    // ...
}
```


##
