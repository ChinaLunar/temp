# 7.4.1 依赖注入 #

依赖注入（Dependency injection，DI）是通过对象定义其依赖的过程，也就是说，一个对象所需要的其他对象，仅通过构造方法传参、工厂方法传参、或者在对象被构造方法实例化、被工厂方法实例化之后通过 setter 赋值的方式传给此对象。而容器负责在实例化对象之后，为对象 *注入* 这些依赖。由于该过程与对象直接自行使用类的构造方法或`Service Locator`模式控制依赖实例化或定位的过程相比，从根本上而言是相反的，所以被称为控制反转（Inversion of Control，IoC）

使用 DI 原理的代码更加简洁，解耦也更加彻底。对象不查找依赖，也不知道依赖的位置和类型。这样一来，类变得更加易于测试，尤其对象依赖的是接口或抽象基类的时候，能够模仿具体的实现进行单元测试

DI 存在两种主要的变种：
  * 基于构造器的依赖注入
  * 基于 setter 的依赖注入


## 基于构造器的依赖注入 ##

基于构造器的依赖注入由容器触发完成，并传入作为依赖的参数。这与使用指定的参数调用静态工厂方法构造 bean 的方式几乎相等，并且在当前的介绍中对构造方法和静态工厂方法的参数的处理是相似的。以下实例展示了一个只能使用构造器依赖注入方式的类。请注意该类没有任何特殊性，只是一个 POJO 并且没有依赖任何容器的接口、基类或注解。

```xml
public class SimpleMovieLister {

    // SimpleMovieLister 依赖于 MovieFinder
    private MovieFinder movieFinder;

    // 准备能让 Spring 注入 MovieFinder 依赖的构造器
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 省略实际使用被注入依赖 MovieFinder 的业务逻辑

}
```


### 构造器传参 ###

在使用含有参数的构造器时需要进行参数匹配。如果 bean 定义的构造器参数不含有潜在的歧义，那么 bean 定义中构造器的参数属性应当和使用构造器实例化类时的参数顺序一致。例如：

```java
package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }

}
```

不存在潜在的歧义，假设 Bar 和 Baz 类没有继承关系。那么如下的配置可以正常执行，并且开发者不需要在`<constructor-arg/>`元素中明确地指明构造器参数的顺序和类型

```xml
<beans>
    <bean id="foo" class="x.y.Foo">
        <constructor-arg ref="bar"/>
        <constructor-arg ref="baz"/>
    </bean>

    <bean id="bar" class="x.y.Bar"/>

    <bean id="baz" class="x.y.Baz"/>
</beans>
```

当被引用 bean 的类型已知的时候，可以根据类型匹配参数（如上方示例）。但是当使用简单的值作为参数的时候，例如`<value>true</value>`，Spring 无法确定值得具体类型，从而无法匹配参数，例如：

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }

}
```

在以下示例中，通过`type`属性指明构造器参数的类型，从而让容器可以根据类型匹配值，例如：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

使用`index`属性可以明确指明构造器参数的顺序。例如：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

使用`index`属性还可以额外解决构造器参数类型相同，不能够根据类型进行参数匹配的问题。需要注意的是：参数的顺序从 0 开始。

开发者还可以使用构造器参数名消除歧义：

```xm
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

但需要注意的是：如果希望使用构造器参数名匹配参数的功能，开发者的代码在编译时必须添加 debug 标志，这样 Spring 才能够从构造器中查询参数名；如果开发者无法使用（或不想使用） debug 标志，可以使用 JDK 的 [`@ConstructorProperties`][constructorProperties]注解明确指出构造器的参数名，例如：

```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }

}
```


## 基于 setter 的依赖注入 ##

基于 setter 的依赖注入由容器在 bean 完成初始化之后，通过调用 bean 的 setter 方法完成注入

如下示例展示了一个仅能通过纯 setter 注入方式注入依赖的类。该类是传统的 POJO，没有依赖容器特定的接口，基类或注解

```xml
public class SimpleMovieLister {

    // SimpleMovieLister 依赖于 MovieFinder
    private MovieFinder movieFinder;

    // 使 Spring 容器能够注入 MovieFinder 的 setter 方法
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 省略实际使用注入的依赖的业务逻辑

}
```

`ApplicationContext`对其管理的 beans 支持基于构造器和 setter 的依赖注入。其也支持在某些依赖通过构造器注入方式注入之后，再使用 setter 方式注入。开发者可以使用`BeanDefinition`的编程格式配置依赖，并结合`PropertyEditor`实例将属性从一种格式转换为另一种格式。然后大多数 Spring 用户不使用这种编程的方式，而是用 XML 定义 bean、注解配置 bean（例如使用`@Component`、`@Controller`等注解声明的类）或基于 Java 的`@Cnofiguration`类的`@Bean`方法配置 bean。这些方式完成的配置都会在内部转换为`BeanDefinition`的实例，并由 Spring IoC 容器进行装载


## 基于构造器注入还是基于 setter 注入？ ##

当开发者可以混用基于构造器的依赖和基于 setter 的依赖之后，应当遵循良好的使用规则：使用构造器注入强制依赖，使用 setter 方法或配置方法注入可选依赖。*注意* 在 setter 方法上使用`@Required`注解可以是相应的属性成为必要的依赖（强制依赖）

Spring 团队通常建议构造器注入作为将应用组件实现为不可变对象并确保必要的依赖非`null`的方式。而且构造器注入方式总是为客户端（调用方）代码返回完全初始化的组件。需要注意的是，有大量构造器参数是一种代码坏味道，一个类在实现时有过多的职责就应该进行重构从而分离关注点

setter 注入方式应当是可选依赖的首选，并在类的内部为属性赋相应的默认值。否则，就需要在使用此依赖的所有位置进行非空检查。setter 注入的好处之一就是，setter 方法使得类的属性能够在实例化之后被重配置或重注入。





























<!-- 链接 -->
[constructorProperties]: http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html
